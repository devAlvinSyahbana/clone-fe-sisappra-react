{"version":3,"file":"static/js/933.3d038031.chunk.js","mappings":"28BAGWA,EAA6B,qBAAXC,OACtB,SAASC,KAMT,SAASC,EAAeC,GAC7B,MAAwB,kBAAVA,GAAsBA,GAAS,GAAKA,IAAUC,EAAAA,EAuNvD,SAASC,EAAiBC,EAAGC,GAClC,GAAID,IAAMC,EACR,OAAOD,EAGT,IAAIE,EAAQC,MAAMC,QAAQJ,IAAMG,MAAMC,QAAQH,GAE9C,GAAIC,GAASG,EAAcL,IAAMK,EAAcJ,GAAI,CAOjD,IANA,IAAIK,EAAQJ,EAAQF,EAAEO,OAASC,OAAOC,KAAKT,GAAGO,OAC1CG,EAASR,EAAQD,EAAIO,OAAOC,KAAKR,GACjCU,EAAQD,EAAOH,OACfK,EAAOV,EAAQ,GAAK,GACpBW,EAAa,EAERC,EAAI,EAAGA,EAAIH,EAAOG,IAAK,CAC9B,IAAIC,EAAMb,EAAQY,EAAIJ,EAAOI,GAC7BF,EAAKG,GAAOhB,EAAiBC,EAAEe,GAAMd,EAAEc,IAEnCH,EAAKG,KAASf,EAAEe,IAClBF,IAIJ,OAAOP,IAAUK,GAASE,IAAeP,EAAQN,EAAIY,EAGvD,OAAOX,EAoBF,SAASI,EAAcW,GAC5B,IAAKC,EAAmBD,GACtB,OAAO,EAIT,IAAIE,EAAOF,EAAEG,YAEb,GAAoB,qBAATD,EACT,OAAO,EAIT,IAAIE,EAAOF,EAAKG,UAEhB,QAAKJ,EAAmBG,MAKnBA,EAAKE,eAAe,iBAQ3B,SAASL,EAAmBD,GAC1B,MAA6C,oBAAtCR,OAAOa,UAAUE,SAASC,KAAKR,GAGjC,SAASS,EAAW5B,GACzB,MAAwB,kBAAVA,GAAsBM,MAAMC,QAAQP,GAe7C,SAAS6B,EAAkBC,GAChCC,QAAQC,UAAUC,KAAKH,GAAUI,OAAM,SAAUC,GAC/C,OAAOC,YAAW,WAChB,MAAMD,QChUL,IAAIE,EAA6B,WACtC,SAASA,IACPC,KAAKC,MAAQ,GACbD,KAAKE,aAAe,EAEpBF,KAAKG,SAAW,SAAUX,GACxBA,KAGFQ,KAAKI,cAAgB,SAAUZ,GAC7BA,KAIJ,IAAIa,EAASN,EAAcb,UAoF3B,OAlFAmB,EAAOC,MAAQ,SAAed,GAC5B,IAAIe,EACJP,KAAKE,eAEL,IACEK,EAASf,IADX,QAGEQ,KAAKE,eAEAF,KAAKE,cACRF,KAAKQ,QAIT,OAAOD,GAGTF,EAAOI,SAAW,SAAkBjB,GAClC,IAAIkB,EAAQV,KAERA,KAAKE,aACPF,KAAKC,MAAMU,KAAKnB,GAEhBD,GAAkB,WAChBmB,EAAMP,SAASX,OASrBa,EAAOO,WAAa,SAAoBpB,GACtC,IAAIqB,EAASb,KAEb,OAAO,WACL,IAAK,IAAIc,EAAOC,UAAU3C,OAAQ4C,EAAO,IAAIhD,MAAM8C,GAAOG,EAAO,EAAGA,EAAOH,EAAMG,IAC/ED,EAAKC,GAAQF,UAAUE,GAGzBJ,EAAOJ,UAAS,WACdjB,EAAS0B,WAAM,EAAQF,QAK7BX,EAAOG,MAAQ,WACb,IAAIW,EAASnB,KAETC,EAAQD,KAAKC,MACjBD,KAAKC,MAAQ,GAETA,EAAM7B,QACRmB,GAAkB,WAChB4B,EAAOf,eAAc,WACnBH,EAAMmB,SAAQ,SAAU5B,GACtB2B,EAAOhB,SAASX,aAY1Ba,EAAOgB,kBAAoB,SAA2BC,GACpDtB,KAAKG,SAAWmB,GAQlBjB,EAAOkB,uBAAyB,SAAgCD,GAC9DtB,KAAKI,cAAgBkB,GAGhBvB,EAlG+B,GAqG7ByB,EAAgB,IAAIzB,ECvGpB0B,E,SAA0BC,wBCCrCF,EAAAA,uBAAqCC,GCArC,IAAIE,EAASC,QACN,SAASC,IACd,OAAOF,ECJF,IAAIA,EAASC,QDOlBD,EELQA,E,eCDNG,EAA8BC,EAAAA,mBAAoBC,GAClDC,EAAyCF,EAAAA,eAAoB,GAOjE,SAASG,EAAsBC,GAC7B,OAAIA,GAAoC,qBAAX5E,QACtBA,OAAO6E,0BACV7E,OAAO6E,wBAA0BN,GAG5BvE,OAAO6E,yBAGTN,EAGF,IAAIO,EAAiB,WAC1B,IAAIC,EAAcP,EAAAA,WAAiBG,EAAsBH,EAAAA,WAAiBE,KAE1E,IAAKK,EACH,MAAM,IAAIC,MAAM,0DAGlB,OAAOD,G,WC5BF,IAAIE,EAA4B,WACrC,SAASA,IACPxC,KAAKyC,UAAY,GAGnB,IAAIpC,EAASmC,EAAatD,UA8B1B,OA5BAmB,EAAOqC,UAAY,SAAmBC,GACpC,IAAIjC,EAAQV,KAERR,EAAWmD,GAAY,aAM3B,OAFA3C,KAAKyC,UAAU9B,KAAKnB,GACpBQ,KAAK4C,cACE,WACLlC,EAAM+B,UAAY/B,EAAM+B,UAAUI,QAAO,SAAUC,GACjD,OAAOA,IAAMtD,KAGfkB,EAAMqC,kBAIV1C,EAAO2C,aAAe,WACpB,OAAOhD,KAAKyC,UAAUrE,OAAS,GAGjCiC,EAAOuC,YAAc,aAGrBvC,EAAO0C,cAAgB,aAGhBP,EAnC8B,GCM5BS,EAAgC,SAAUC,GAGnD,SAASD,EAAiBE,EAAQC,GAChC,IAAI1C,EAWJ,OATAA,EAAQwC,EAAc7D,KAAKW,OAASA,MAC9BmD,OAASA,EAEfzC,EAAM2C,WAAWD,GAEjB1C,EAAM4C,cAEN5C,EAAM6C,eAEC7C,GAdT8C,EAAAA,EAAAA,GAAeP,EAAkBC,GAiBjC,IAAI7C,EAAS4C,EAAiB/D,UAoG9B,OAlGAmB,EAAOiD,YAAc,WACnBtD,KAAKyD,OAASzD,KAAKyD,OAAOC,KAAK1D,MAC/BA,KAAK2D,MAAQ3D,KAAK2D,MAAMD,KAAK1D,OAG/BK,EAAOgD,WAAa,SAAoBD,GACtCpD,KAAKoD,QAAUpD,KAAKmD,OAAOS,uBAAuBR,IAGpD/C,EAAO0C,cAAgB,WAEnB,IAAIc,EADD7D,KAAKyC,UAAUrE,SAGgC,OAAjDyF,EAAwB7D,KAAK8D,kBAAoCD,EAAsBE,eAAe/D,QAI3GK,EAAO2D,iBAAmB,SAA0BC,GAClDjE,KAAKuD,eAEL,IAAIW,EAAgB,CAClBzB,WAAW,GAGO,YAAhBwB,EAAOE,KACTD,EAAcE,WAAY,EACD,UAAhBH,EAAOE,OAChBD,EAAcG,SAAU,GAG1BrE,KAAKsE,OAAOJ,IAGd7D,EAAOkE,iBAAmB,WACxB,OAAOvE,KAAKwE,eAGdnE,EAAOsD,MAAQ,WACb3D,KAAK8D,qBAAkB9B,EACvBhC,KAAKuD,eACLvD,KAAKsE,OAAO,CACV7B,WAAW,KAIfpC,EAAOoD,OAAS,SAAgBgB,EAAWrB,GAWzC,OAVApD,KAAK0E,cAAgBtB,EAEjBpD,KAAK8D,iBACP9D,KAAK8D,gBAAgBC,eAAe/D,MAGtCA,KAAK8D,gBAAkB9D,KAAKmD,OAAOwB,mBAAmBC,MAAM5E,KAAKmD,QAAQ0B,EAAAA,EAAAA,GAAS,GAAI7E,KAAKoD,QAAS,CAClGqB,UAAgC,qBAAdA,EAA4BA,EAAYzE,KAAKoD,QAAQqB,aAEzEzE,KAAK8D,gBAAgBgB,YAAY9E,MAC1BA,KAAK8D,gBAAgBiB,WAG9B1E,EAAOkD,aAAe,WACpB,IAAIyB,EAAQhF,KAAK8D,gBAAkB9D,KAAK8D,gBAAgBkB,MCoFnD,CACLC,aAASjD,EACTkD,UAAMlD,EACNnC,MAAO,KACPsF,aAAc,EACdC,UAAU,EACVC,OAAQ,OACRZ,eAAWzC,GDzFPzB,GAASsE,EAAAA,EAAAA,GAAS,GAAIG,EAAO,CAC/BM,UAA4B,YAAjBN,EAAMK,OACjBE,UAA4B,YAAjBP,EAAMK,OACjBG,QAA0B,UAAjBR,EAAMK,OACfI,OAAyB,SAAjBT,EAAMK,OACd5B,OAAQzD,KAAKyD,OACbE,MAAO3D,KAAK2D,QAGd3D,KAAKwE,cAAgBjE,GAGvBF,EAAOiE,OAAS,SAAgBlB,GAC9B,IAAIvC,EAASb,KAEbwB,EAAAA,OAAoB,WAEdX,EAAO6D,gBACLtB,EAAQgB,WACwB,MAAlCvD,EAAO6D,cAAcN,WAA6BvD,EAAO6D,cAAcN,UAAUvD,EAAO2D,cAAcU,KAAMrE,EAAO2D,cAAcC,UAAW5D,EAAO2D,cAAcS,SAC/H,MAAlCpE,EAAO6D,cAAcgB,WAA6B7E,EAAO6D,cAAcgB,UAAU7E,EAAO2D,cAAcU,KAAM,KAAMrE,EAAO2D,cAAcC,UAAW5D,EAAO2D,cAAcS,UAC9J7B,EAAQiB,UACe,MAAhCxD,EAAO6D,cAAcL,SAA2BxD,EAAO6D,cAAcL,QAAQxD,EAAO2D,cAAc3E,MAAOgB,EAAO2D,cAAcC,UAAW5D,EAAO2D,cAAcS,SAC5H,MAAlCpE,EAAO6D,cAAcgB,WAA6B7E,EAAO6D,cAAcgB,eAAU1D,EAAWnB,EAAO2D,cAAc3E,MAAOgB,EAAO2D,cAAcC,UAAW5D,EAAO2D,cAAcS,WAK7K7B,EAAQX,WACV5B,EAAO4B,UAAUrB,SAAQ,SAAUuB,GACjCA,EAAS9B,EAAO2D,sBAMjBvB,EAtHkC,CAuHzCT,GE7HK,SAASmD,EAAiBC,EAAUC,EAAmBC,GAE5D,MAAiC,oBAAtBD,EACFA,EAAkB3E,WAAM,EAAQ4E,GAIR,mBAAtBD,EAAwCA,IAE1CD,ECDJ,SAASG,EAAYC,EAAMC,EAAMC,GACtC,IAAIC,EAAapE,EAAAA,QAAa,GAG1BqE,EADkBrE,EAAAA,SAAe,GACH,GAE9BqB,EZ+BC,SAA2B4C,EAAMC,EAAMC,GAC5C,OAAI5G,EAAW0G,GACO,oBAATC,GACFpB,EAAAA,EAAAA,GAAS,GAAIqB,EAAM,CACxBG,YAAaL,EACbM,WAAYL,KAITpB,EAAAA,EAAAA,GAAS,GAAIoB,EAAM,CACxBI,YAAaL,IAIG,oBAATA,GACFnB,EAAAA,EAAAA,GAAS,GAAIoB,EAAM,CACxBK,WAAYN,KAITnB,EAAAA,EAAAA,GAAS,GAAImB,GYnDNO,CAAkBP,EAAMC,EAAMC,GACxC5D,EAAcD,IACdmE,EAASzE,EAAAA,SAERyE,EAAOC,QAGVD,EAAOC,QAAQpD,WAAWD,GAF1BoD,EAAOC,QAAU,IAAIxD,EAAiBX,EAAac,GAKrD,IAAIoB,EAAgBgC,EAAOC,QAAQlC,mBACnCxC,EAAAA,WAAgB,WACdoE,EAAWM,SAAU,EACrB,IAAIC,EAAcF,EAAOC,QAAQ/D,UAAUlB,EAAAA,YAAyB,WAC9D2E,EAAWM,SACbL,GAAY,SAAUtD,GACpB,OAAOA,EAAI,SAIjB,OAAO,WACLqD,EAAWM,SAAU,EACrBC,OAED,IACH,IAAIjD,EAAS1B,EAAAA,aAAkB,SAAU0C,EAAWC,GAClD8B,EAAOC,QAAQhD,OAAOgB,EAAWC,GAAe9E,MAAMpC,KACrD,IAEH,GAAIgH,EAAc3E,OAAS8F,OAAiB3D,EAAWwE,EAAOC,QAAQrD,QAAQuD,iBAAkB,CAACnC,EAAc3E,QAC7G,MAAM2E,EAAc3E,MAGtB,OAAOgF,EAAAA,EAAAA,GAAS,GAAIL,EAAe,CACjCf,OAAQA,EACRmD,YAAapC,EAAcf,SC9CxB,IA2FIoD,EAAe,IA3Fa,SAAU3D,GAG/C,SAAS4D,IACP,IAAIpG,EAuBJ,OArBAA,EAAQwC,EAAc7D,KAAKW,OAASA,MAE9B+G,MAAQ,SAAUC,GACtB,IAAIC,EAEJ,IAAK3J,IAAmC,OAArB2J,EAAU1J,aAAkB,EAAS0J,EAAQC,kBAAmB,CACjF,IAAIvE,EAAW,WACb,OAAOqE,KAMT,OAFAzJ,OAAO2J,iBAAiB,mBAAoBvE,GAAU,GACtDpF,OAAO2J,iBAAiB,QAASvE,GAAU,GACpC,WAELpF,OAAO4J,oBAAoB,mBAAoBxE,GAC/CpF,OAAO4J,oBAAoB,QAASxE,MAKnCjC,GA1BT8C,EAAAA,EAAAA,GAAesD,EAAc5D,GA6B7B,IAAI7C,EAASyG,EAAa5H,UA2D1B,OAzDAmB,EAAOuC,YAAc,WACd5C,KAAKoH,SACRpH,KAAKqH,iBAAiBrH,KAAK+G,QAI/B1G,EAAO0C,cAAgB,WAEnB,IAAIuE,EADDtH,KAAKgD,iBAG0B,OAAjCsE,EAAgBtH,KAAKoH,UAA4BE,EAAcjI,KAAKW,MACrEA,KAAKoH,aAAUpF,IAInB3B,EAAOgH,iBAAmB,SAA0BN,GAClD,IAAIQ,EACA1G,EAASb,KAEbA,KAAK+G,MAAQA,EACsB,OAAlCQ,EAAiBvH,KAAKoH,UAA4BG,EAAelI,KAAKW,MACvEA,KAAKoH,QAAUL,GAAM,SAAUS,GACN,mBAAZA,EACT3G,EAAO4G,WAAWD,GAElB3G,EAAOmG,cAKb3G,EAAOoH,WAAa,SAAoBD,GACtCxH,KAAKwH,QAAUA,EAEXA,GACFxH,KAAKgH,WAIT3G,EAAO2G,QAAU,WACfhH,KAAKyC,UAAUrB,SAAQ,SAAUuB,GAC/BA,QAIJtC,EAAOqH,UAAY,WACjB,MAA4B,mBAAjB1H,KAAKwH,QACPxH,KAAKwH,QAIU,qBAAbG,UAIJ,MAAC3F,EAAW,UAAW,aAAa4F,SAASD,SAASE,kBAGxDf,EAzF8B,CA0FrCtE,IClFK,IAAIsF,EAAiB,SAAwB1E,GAClDpD,KAAK+H,OAAoB,MAAX3E,OAAkB,EAASA,EAAQ2E,OACjD/H,KAAKgI,OAAoB,MAAX5E,OAAkB,EAASA,EAAQ4E,QAM5C,ICXIC,EAA6B,SAAU/E,GAGhD,SAAS+E,EAAc9E,EAAQC,GAC7B,IAAI1C,EAYJ,OAVAA,EAAQwC,EAAc7D,KAAKW,OAASA,MAC9BmD,OAASA,EACfzC,EAAM0C,QAAUA,EAChB1C,EAAMwH,aAAe,GACrBxH,EAAMyH,oBAAsB,KAE5BzH,EAAM4C,cAEN5C,EAAM2C,WAAWD,GAEV1C,GAfT8C,EAAAA,EAAAA,GAAeyE,EAAe/E,GAkB9B,IAAI7C,EAAS4H,EAAc/I,UA8e3B,OA5eAmB,EAAOiD,YAAc,WACnBtD,KAAKoI,OAASpI,KAAKoI,OAAO1E,KAAK1D,MAC/BA,KAAKqI,QAAUrI,KAAKqI,QAAQ3E,KAAK1D,OAGnCK,EAAOuC,YAAc,WACW,IAA1B5C,KAAKyC,UAAUrE,SACjB4B,KAAKsI,aAAaxD,YAAY9E,MAE1BuI,EAAmBvI,KAAKsI,aAActI,KAAKoD,UAC7CpD,KAAKwI,eAGPxI,KAAKyI,iBAITpI,EAAO0C,cAAgB,WAChB/C,KAAKyC,UAAUrE,QAClB4B,KAAK0I,WAITrI,EAAOsI,uBAAyB,WAC9B,OAAOC,EAAc5I,KAAKsI,aAActI,KAAKoD,QAASpD,KAAKoD,QAAQyF,qBAGrExI,EAAOyI,yBAA2B,WAChC,OAAOF,EAAc5I,KAAKsI,aAActI,KAAKoD,QAASpD,KAAKoD,QAAQ2F,uBAGrE1I,EAAOqI,QAAU,WACf1I,KAAKyC,UAAY,GACjBzC,KAAKgJ,cACLhJ,KAAKsI,aAAavE,eAAe/D,OAGnCK,EAAOgD,WAAa,SAAoBD,EAASc,GAC/C,IAAI+E,EAAcjJ,KAAKoD,QACnB8F,EAAYlJ,KAAKsI,aAGrB,GAFAtI,KAAKoD,QAAUpD,KAAKmD,OAAOgG,4BAA4B/F,GAEnB,qBAAzBpD,KAAKoD,QAAQgG,SAA2D,mBAAzBpJ,KAAKoD,QAAQgG,QACrE,MAAM,IAAI7G,MAAM,oCAIbvC,KAAKoD,QAAQiG,WAChBrJ,KAAKoD,QAAQiG,SAAWJ,EAAYI,UAGtCrJ,KAAKsJ,cACL,IAAIC,EAAUvJ,KAAKgD,eAEfuG,GAAWC,EAAsBxJ,KAAKsI,aAAcY,EAAWlJ,KAAKoD,QAAS6F,IAC/EjJ,KAAKwI,eAIPxI,KAAKuD,aAAaW,IAEdqF,GAAYvJ,KAAKsI,eAAiBY,GAAalJ,KAAKoD,QAAQgG,UAAYH,EAAYG,SAAWpJ,KAAKoD,QAAQqG,YAAcR,EAAYQ,WACxIzJ,KAAK0J,qBAGP,IAAIC,EAAsB3J,KAAK4J,0BAE3BL,GAAYvJ,KAAKsI,eAAiBY,GAAalJ,KAAKoD,QAAQgG,UAAYH,EAAYG,SAAWO,IAAwB3J,KAAK6J,wBAC9H7J,KAAK8J,sBAAsBH,IAI/BtJ,EAAO0J,oBAAsB,SAA6B3G,GACxD,IAAI4G,EAAmBhK,KAAKmD,OAAOgG,4BAA4B/F,GAC3D6G,EAAQjK,KAAKmD,OAAO+G,gBAAgBtF,MAAM5E,KAAKmD,OAAQ6G,GAC3D,OAAOhK,KAAKmK,aAAaF,EAAOD,IAGlC3J,EAAOkE,iBAAmB,WACxB,OAAOvE,KAAKwE,eAGdnE,EAAO+J,YAAc,SAAqB7J,EAAQyJ,GAChD,IAAInJ,EAASb,KAETqK,EAAgB,GAEhBC,EAAY,SAAmB1L,GAC5BiC,EAAOqH,aAAaN,SAAShJ,IAChCiC,EAAOqH,aAAavH,KAAK/B,IAmB7B,OAfAP,OAAOC,KAAKiC,GAAQa,SAAQ,SAAUxC,GACpCP,OAAOkM,eAAeF,EAAezL,EAAK,CACxC4L,cAAc,EACdC,YAAY,EACZC,IAAK,WAEH,OADAJ,EAAU1L,GACH2B,EAAO3B,UAKhBoL,EAAiBrD,kBAAoBqD,EAAiBpE,WACxD0E,EAAU,SAGLD,GAGThK,EAAOsK,cAAgB,SAAuBvH,GAC5C,IAAIjC,EAASnB,KAEb,OAAO,IAAIP,SAAQ,SAAUC,EAASkL,GACpC,IAAIlE,EAAcvF,EAAOuB,WAAU,SAAUnC,GACtCA,EAAOsK,aACVnE,IAEInG,EAAOiF,UAAuB,MAAXpC,OAAkB,EAASA,EAAQ0H,cACxDF,EAAOrK,EAAOV,OAEdH,EAAQa,WAOlBF,EAAO0K,gBAAkB,WACvB,OAAO/K,KAAKsI,cAGdjI,EAAO+H,OAAS,WACdpI,KAAKmD,OAAO+G,gBAAgB9B,OAAOpI,KAAKsI,eAG1CjI,EAAOgI,QAAU,SAAiBjF,GAChC,OAAOpD,KAAKgL,OAAMnG,EAAAA,EAAAA,GAAS,GAAIzB,EAAS,CACtC6H,KAAM,CACJC,YAAwB,MAAX9H,OAAkB,EAASA,EAAQ8H,iBAKtD7K,EAAO8K,gBAAkB,SAAyB/H,GAChD,IAAIgI,EAASpL,KAETgK,EAAmBhK,KAAKmD,OAAOgG,4BAA4B/F,GAC3D6G,EAAQjK,KAAKmD,OAAO+G,gBAAgBtF,MAAM5E,KAAKmD,OAAQ6G,GAC3D,OAAOC,EAAMe,QAAQrL,MAAK,WACxB,OAAOyL,EAAOjB,aAAaF,EAAOD,OAItC3J,EAAO2K,MAAQ,SAAeK,GAC5B,IAAIC,EAAStL,KAEb,OAAOA,KAAKwI,aAAa6C,GAAc1L,MAAK,WAG1C,OAFA2L,EAAO/H,eAEA+H,EAAO9G,kBAIlBnE,EAAOmI,aAAe,SAAsB6C,GAE1CrL,KAAKsJ,cAEL,IAAIiC,EAAUvL,KAAKsI,aAAa0C,MAAMhL,KAAKoD,QAASiI,GAMpD,OAJsB,MAAhBA,OAAuB,EAASA,EAAaP,gBACjDS,EAAUA,EAAQ3L,MAAMpC,IAGnB+N,GAGTlL,EAAOqJ,mBAAqB,WAC1B,IAAI8B,EAASxL,KAIb,GAFAA,KAAKyL,qBAEDnO,IAAY0C,KAAKwE,cAAckH,SAAYjO,EAAeuC,KAAKoD,QAAQqG,WAA3E,CAIA,If9L2BkC,EAAWlC,EeiMlCmC,GfjMuBD,Ee8LD3L,KAAKwE,cAAcqH,cf9LPpC,Ee8LsBzJ,KAAKoD,QAAQqG,Uf7LpEqC,KAAKC,IAAIJ,GAAalC,GAAa,GAAKuC,KAAKC,MAAO,IegMpC,EACrBjM,KAAKkM,eAAiBpM,YAAW,WAC1B0L,EAAOhH,cAAckH,SACxBF,EAAOjI,iBAERqI,KAGLvL,EAAOuJ,uBAAyB,WAC9B,IAAIuC,EAEJ,MAA+C,oBAAjCnM,KAAKoD,QAAQgJ,gBAAiCpM,KAAKoD,QAAQgJ,gBAAgBpM,KAAKwE,cAAcU,KAAMlF,KAAKsI,cAA0E,OAAzD6D,EAAwBnM,KAAKoD,QAAQgJ,kBAA2BD,GAG1M9L,EAAOyJ,sBAAwB,SAA+BuC,GAC5D,IAAIC,EAAStM,KAEbA,KAAKuM,uBACLvM,KAAK6J,uBAAyBwC,GAE1B/O,IAAqC,IAAzB0C,KAAKoD,QAAQgG,SAAsB3L,EAAeuC,KAAK6J,yBAA2D,IAAhC7J,KAAK6J,yBAIvG7J,KAAKwM,kBAAoBC,aAAY,YAC/BH,EAAOlJ,QAAQsJ,6BAA+B7F,EAAAA,cAChDyF,EAAO9D,iBAERxI,KAAK6J,0BAGVxJ,EAAOoI,aAAe,WACpBzI,KAAK0J,qBACL1J,KAAK8J,sBAAsB9J,KAAK4J,2BAGlCvJ,EAAO2I,YAAc,WACnBhJ,KAAKyL,oBACLzL,KAAKuM,wBAGPlM,EAAOoL,kBAAoB,WACzBkB,aAAa3M,KAAKkM,gBAClBlM,KAAKkM,oBAAiBlK,GAGxB3B,EAAOkM,qBAAuB,WAC5BK,cAAc5M,KAAKwM,mBACnBxM,KAAKwM,uBAAoBxK,GAG3B3B,EAAO8J,aAAe,SAAsBF,EAAO7G,GACjD,IAgBI8B,EAhBAgE,EAAYlJ,KAAKsI,aACjBW,EAAcjJ,KAAKoD,QACnByJ,EAAa7M,KAAKwE,cAClBsI,EAAkB9M,KAAK+M,mBACvBC,EAAoBhN,KAAKiN,qBACzBC,EAAcjD,IAAUf,EACxBiE,EAAoBD,EAAcjD,EAAMjF,MAAQhF,KAAKoN,yBACrDC,EAAkBH,EAAclN,KAAKwE,cAAgBxE,KAAKsN,oBAC1DtI,EAAQiF,EAAMjF,MACd6G,EAAgB7G,EAAM6G,cACtBhM,EAAQmF,EAAMnF,MACd0N,EAAiBvI,EAAMuI,eACvB1C,EAAa7F,EAAM6F,WACnBxF,EAASL,EAAMK,OACfmI,GAAiB,EACjBC,GAAoB,EAGxB,GAAIrK,EAAQsK,kBAAmB,CAC7B,IAAInE,EAAUvJ,KAAKgD,eACf2K,GAAgBpE,GAAWhB,EAAmB0B,EAAO7G,GACrDwK,EAAkBrE,GAAWC,EAAsBS,EAAOf,EAAW9F,EAAS6F,IAE9E0E,GAAgBC,KAClB/C,GAAa,EAERgB,IACHxG,EAAS,YAMf,GAAIjC,EAAQyK,mBAAqB7I,EAAM8I,kBAAuC,MAAnBT,OAA0B,EAASA,EAAgB9H,YAAyB,UAAXF,EAC1HH,EAAOmI,EAAgBnI,KACvB2G,EAAgBwB,EAAgBxB,cAChCxG,EAASgI,EAAgBhI,OACzBmI,GAAiB,OAEd,GAAIpK,EAAQ2K,QAAgC,qBAAf/I,EAAME,KAAsB,CAC1D,IAAI8I,EAGJ,GAAInB,GAAc7H,EAAME,QAA6B,MAAnB4H,OAA0B,EAASA,EAAgB5H,OAAS9B,EAAQ2K,UAA4D,OAA/CC,EAAuBhO,KAAKiO,qBAA0B,EAASD,EAAqB1M,MAAQtB,KAAKmI,oBAClNjD,EAAOlF,KAAKiO,eAAe1N,YAE3B,IACE2E,EAAO9B,EAAQ2K,OAAO/I,EAAME,OAEM,IAA9B9B,EAAQ8K,oBACVhJ,EAAOtH,EAA+B,MAAdiP,OAAqB,EAASA,EAAW3H,KAAMA,IAGzElF,KAAKiO,eAAiB,CACpB3M,GAAI8B,EAAQ2K,OACZxN,OAAQ2E,GAEVlF,KAAKmI,oBAAsB,KAC3B,MAAOgG,GACPtM,IAAYhC,MAAMsO,GAClBtO,EAAQsO,EACRnO,KAAKmI,oBAAsBgG,EAC3BZ,EAAiBvB,KAAKC,MACtB5G,EAAS,cAKXH,EAAOF,EAAME,KAInB,GAAuC,qBAA5B9B,EAAQgL,iBAAmD,qBAATlJ,IAAoC,YAAXG,GAAmC,SAAXA,GAAoB,CAChI,IAAI+I,EAEJ,IAAmB,MAAdvB,OAAqB,EAASA,EAAWY,oBAAsBrK,EAAQgL,mBAA0C,MAArBpB,OAA4B,EAASA,EAAkBoB,iBACtJA,EAAkBvB,EAAW3H,UAI7B,GAFAkJ,EAAqD,oBAA5BhL,EAAQgL,gBAAiChL,EAAQgL,kBAAoBhL,EAAQgL,gBAElGhL,EAAQ2K,QAAqC,qBAApBK,EAC3B,IACEA,EAAkBhL,EAAQ2K,OAAOK,IAEC,IAA9BhL,EAAQ8K,oBACVE,EAAkBxQ,EAA+B,MAAdiP,OAAqB,EAASA,EAAW3H,KAAMkJ,IAGpFpO,KAAKmI,oBAAsB,KAC3B,MAAOgG,GACPtM,IAAYhC,MAAMsO,GAClBtO,EAAQsO,EACRnO,KAAKmI,oBAAsBgG,EAC3BZ,EAAiBvB,KAAKC,MACtB5G,EAAS,QAKgB,qBAApB+I,IACT/I,EAAS,UACTH,EAAOkJ,EACPX,GAAoB,GA4BxB,MAxBa,CACXpI,OAAQA,EACRC,UAAsB,YAAXD,EACXE,UAAsB,YAAXF,EACXG,QAAoB,UAAXH,EACTI,OAAmB,SAAXJ,EACRH,KAAMA,EACN2G,cAAeA,EACfhM,MAAOA,EACP0N,eAAgBA,EAChBpI,aAAcH,EAAMqJ,kBACpBC,iBAAkBtJ,EAAMsJ,iBACxBC,UAAWvJ,EAAM8I,gBAAkB,GAAK9I,EAAMsJ,iBAAmB,EACjEE,oBAAqBxJ,EAAM8I,gBAAkBX,EAAkBW,iBAAmB9I,EAAMsJ,iBAAmBnB,EAAkBmB,iBAC7HzD,WAAYA,EACZ4D,aAAc5D,GAAyB,YAAXxF,EAC5BqJ,eAA2B,UAAXrJ,GAA8C,IAAxBL,EAAM6G,cAC5C4B,kBAAmBA,EACnBD,eAAgBA,EAChBmB,eAA2B,UAAXtJ,GAA8C,IAAxBL,EAAM6G,cAC5CH,QAASA,EAAQzB,EAAO7G,GACxBiF,QAASrI,KAAKqI,QACdD,OAAQpI,KAAKoI,SAKjB/H,EAAOuO,sBAAwB,SAA+BrO,EAAQsM,GACpE,IAAKA,EACH,OAAO,EAGT,IAAIgC,EAAgB7O,KAAKoD,QACrB0L,EAAsBD,EAAcC,oBACpCC,EAAgCF,EAAcE,8BAElD,IAAKD,IAAwBC,EAC3B,OAAO,EAGT,GAA4B,YAAxBD,IAAsC9O,KAAKkI,aAAa9J,OAC1D,OAAO,EAGT,IAAI4Q,EAAwC,YAAxBF,EAAoC9O,KAAKkI,aAAe4G,EAC5E,OAAOzQ,OAAOC,KAAKiC,GAAQ0O,MAAK,SAAUrQ,GACxC,IAAIsQ,EAAWtQ,EACXuQ,EAAU5O,EAAO2O,KAAcrC,EAAWqC,GAC1CE,EAA8B,MAAjBJ,OAAwB,EAASA,EAAcC,MAAK,SAAUnM,GAC7E,OAAOA,IAAMlE,KAEXyQ,EAA8C,MAAjCN,OAAwC,EAASA,EAA8BE,MAAK,SAAUnM,GAC7G,OAAOA,IAAMlE,KAEf,OAAOuQ,IAAYE,KAAgBL,GAAiBI,OAIxD/O,EAAOkD,aAAe,SAAsBW,GAC1C,IAAI2I,EAAa7M,KAAKwE,cAKtB,GAJAxE,KAAKwE,cAAgBxE,KAAKmK,aAAanK,KAAKsI,aAActI,KAAKoD,SAC/DpD,KAAK+M,mBAAqB/M,KAAKsI,aAAatD,MAC5ChF,KAAKiN,qBAAuBjN,KAAKoD,SfrL9B,SAA6BvF,EAAGC,GACrC,GAAID,IAAMC,GAAKA,IAAMD,EACnB,OAAO,EAGT,IAAK,IAAIe,KAAOf,EACd,GAAIA,EAAEe,KAASd,EAAEc,GACf,OAAO,EAIX,OAAO,Ee4KD0Q,CAAoBtP,KAAKwE,cAAeqI,GAA5C,CAKA,IAAI0C,EAAuB,CACzBC,OAAO,IAG0D,KAA7C,MAAjBtL,OAAwB,EAASA,EAAczB,YAAwBzC,KAAK4O,sBAAsB5O,KAAKwE,cAAeqI,KACzH0C,EAAqB9M,WAAY,GAGnCzC,KAAKsE,QAAOO,EAAAA,EAAAA,GAAS,GAAI0K,EAAsBrL,MAGjD7D,EAAOiJ,YAAc,WACnB,IAAIW,EAAQjK,KAAKmD,OAAO+G,gBAAgBtF,MAAM5E,KAAKmD,OAAQnD,KAAKoD,SAEhE,GAAI6G,IAAUjK,KAAKsI,aAAnB,CAIA,IAAIY,EAAYlJ,KAAKsI,aACrBtI,KAAKsI,aAAe2B,EACpBjK,KAAKoN,yBAA2BnD,EAAMjF,MACtChF,KAAKsN,oBAAsBtN,KAAKwE,cAE5BxE,KAAKgD,iBACM,MAAbkG,GAA6BA,EAAUnF,eAAe/D,MACtDiK,EAAMnF,YAAY9E,SAItBK,EAAOoP,cAAgB,SAAuBxL,GAC5C,IAAIC,EAAgB,GAEA,YAAhBD,EAAOE,KACTD,EAAcE,WAAY,EACD,UAAhBH,EAAOE,MAAsCF,EAAOpE,iBDhdzCiI,ICidpB5D,EAAcG,SAAU,GAG1BrE,KAAKuD,aAAaW,GAEdlE,KAAKgD,gBACPhD,KAAKyI,gBAITpI,EAAOiE,OAAS,SAAgBJ,GAC9B,IAAIwL,EAAS1P,KAEbwB,EAAAA,OAAoB,WAEd0C,EAAcE,WACY,MAA5BsL,EAAOtM,QAAQgB,WAA6BsL,EAAOtM,QAAQgB,UAAUsL,EAAOlL,cAAcU,MAC9D,MAA5BwK,EAAOtM,QAAQsC,WAA6BgK,EAAOtM,QAAQsC,UAAUgK,EAAOlL,cAAcU,KAAM,OACvFhB,EAAcG,UACG,MAA1BqL,EAAOtM,QAAQiB,SAA2BqL,EAAOtM,QAAQiB,QAAQqL,EAAOlL,cAAc3E,OAC1D,MAA5B6P,EAAOtM,QAAQsC,WAA6BgK,EAAOtM,QAAQsC,eAAU1D,EAAW0N,EAAOlL,cAAc3E,QAInGqE,EAAczB,WAChBiN,EAAOjN,UAAUrB,SAAQ,SAAUuB,GACjCA,EAAS+M,EAAOlL,kBAKhBN,EAAcsL,OAChBE,EAAOvM,OAAO+G,gBAAgB5F,OAAO,CACnC2F,MAAOyF,EAAOpH,aACdnE,KAAM,+BAMP8D,EAjgB+B,CAkgBtCzF,GAMF,SAAS+F,EAAmB0B,EAAO7G,GACjC,OALF,SAA2B6G,EAAO7G,GAChC,OAA2B,IAApBA,EAAQgG,UAAsBa,EAAMjF,MAAM6G,iBAA0C,UAAvB5B,EAAMjF,MAAMK,SAA+C,IAAzBjC,EAAQuM,cAIvGC,CAAkB3F,EAAO7G,IAAY6G,EAAMjF,MAAM6G,cAAgB,GAAKjD,EAAcqB,EAAO7G,EAASA,EAAQyM,gBAGrH,SAASjH,EAAcqB,EAAO7G,EAAS0M,GACrC,IAAwB,IAApB1M,EAAQgG,QAAmB,CAC7B,IAAI1L,EAAyB,oBAAVoS,EAAuBA,EAAM7F,GAAS6F,EACzD,MAAiB,WAAVpS,IAAgC,IAAVA,GAAmBgO,EAAQzB,EAAO7G,GAGjE,OAAO,EAGT,SAASoG,EAAsBS,EAAOf,EAAW9F,EAAS6F,GACxD,OAA2B,IAApB7F,EAAQgG,UAAsBa,IAAUf,IAAqC,IAAxBD,EAAYG,YAAwBhG,EAAQwC,UAAmC,UAAvBqE,EAAMjF,MAAMK,SAAuBqG,EAAQzB,EAAO7G,GAGxK,SAASsI,EAAQzB,EAAO7G,GACtB,OAAO6G,EAAM8F,cAAc3M,EAAQqG,WChiBrC,SAASuG,IACP,IAAIC,GAAW,EACf,MAAO,CACLC,WAAY,WACVD,GAAW,GAEbtM,MAAO,WACLsM,GAAW,GAEbE,QAAS,WACP,OAAOF,IAKb,IAAIG,EAA8CrO,EAAAA,cAAoBiO,KCZ/D,SAASK,EAAajN,EAASkN,GACpC,IAAInK,EAAapE,EAAAA,QAAa,GAG1BqE,EADkBrE,EAAAA,SAAe,GACH,GAE9BO,EAAcD,IACdkO,EDQGxO,EAAAA,WAAiBqO,GCPpBpG,EAAmB1H,EAAY6G,4BAA4B/F,GAE/D4G,EAAiB0D,mBAAoB,EAEjC1D,EAAiB3F,UACnB2F,EAAiB3F,QAAU7C,EAAAA,WAAyBwI,EAAiB3F,UAGnE2F,EAAiB5F,YACnB4F,EAAiB5F,UAAY5C,EAAAA,WAAyBwI,EAAiB5F,YAGrE4F,EAAiBtE,YACnBsE,EAAiBtE,UAAYlE,EAAAA,WAAyBwI,EAAiBtE,YAGrEsE,EAAiBpE,WAGuB,kBAA/BoE,EAAiBP,YAC1BO,EAAiBP,UAAY,KAKI,IAA/BO,EAAiBwG,YACnBxG,EAAiBwG,UAAY,KAI7BxG,EAAiBpE,UAAYoE,EAAiBrD,oBAE3C4J,EAAmBJ,YACtBnG,EAAiB2F,cAAe,IAIpC,IAGIc,EAHmB1O,EAAAA,UAAe,WACpC,OAAO,IAAIuO,EAAShO,EAAa0H,MAEH,GAE5BzJ,EAASkQ,EAAS1G,oBAAoBC,GA2B1C,GA1BAjI,EAAAA,WAAgB,WACdoE,EAAWM,SAAU,EACrB8J,EAAmBL,aACnB,IAAIxJ,EAAc+J,EAAS/N,UAAUlB,EAAAA,YAAyB,WACxD2E,EAAWM,SACbL,GAAY,SAAUtD,GACpB,OAAOA,EAAI,SAOjB,OADA2N,EAASlN,eACF,WACL4C,EAAWM,SAAU,EACrBC,OAED,CAAC6J,EAAoBE,IACxB1O,EAAAA,WAAgB,WAGd0O,EAASpN,WAAW2G,EAAkB,CACpCvH,WAAW,MAEZ,CAACuH,EAAkByG,IAElBzG,EAAiBpE,UAAYrF,EAAO+E,UACtC,MAAMmL,EAAStF,gBAAgBnB,GAAkBrK,MAAK,SAAU+Q,GAC9D,IAAIxL,EAAOwL,EAAKxL,KACc,MAA9B8E,EAAiB5F,WAA6B4F,EAAiB5F,UAAUc,GAC3C,MAA9B8E,EAAiBtE,WAA6BsE,EAAiBtE,UAAUR,EAAM,SAC9EtF,OAAM,SAAUC,GACjB0Q,EAAmBL,aACS,MAA5BlG,EAAiB3F,SAA2B2F,EAAiB3F,QAAQxE,GACvC,MAA9BmK,EAAiBtE,WAA6BsE,EAAiBtE,eAAU1D,EAAWnC,MAKxF,GAAIU,EAAOiF,UAAY+K,EAAmBJ,YAAc5P,EAAOsK,YAAclF,EAAiBqE,EAAiBpE,SAAUoE,EAAiBrD,iBAAkB,CAACpG,EAAOV,MAAO4Q,EAAS1F,oBAClL,MAAMxK,EAAOV,MAQf,MAJ6C,YAAzCmK,EAAiB8E,sBACnBvO,EAASkQ,EAASrG,YAAY7J,EAAQyJ,IAGjCzJ,ECpGF,SAASoQ,EAAS3K,EAAMC,EAAMC,GACnC,IAAI0K,ElBwBC,SAAwB5K,EAAMC,EAAMC,GACzC,OAAK5G,EAAW0G,GAII,oBAATC,GACFpB,EAAAA,EAAAA,GAAS,GAAIqB,EAAM,CACxBmD,SAAUrD,EACV6K,QAAS5K,KAINpB,EAAAA,EAAAA,GAAS,GAAIoB,EAAM,CACxBoD,SAAUrD,IAXHA,EkB1BW8K,CAAe9K,EAAMC,EAAMC,GAC/C,OAAOmK,EAAaO,EAAe3I","sources":["../node_modules/react-query/es/core/utils.js","../node_modules/react-query/es/core/notifyManager.js","../node_modules/react-query/es/react/reactBatchedUpdates.js","../node_modules/react-query/es/react/setBatchUpdatesFn.js","../node_modules/react-query/es/core/logger.js","../node_modules/react-query/es/react/logger.js","../node_modules/react-query/es/react/setLogger.js","../node_modules/react-query/es/react/QueryClientProvider.js","../node_modules/react-query/es/core/subscribable.js","../node_modules/react-query/es/core/mutationObserver.js","../node_modules/react-query/es/core/mutation.js","../node_modules/react-query/es/react/utils.js","../node_modules/react-query/es/react/useMutation.js","../node_modules/react-query/es/core/focusManager.js","../node_modules/react-query/es/core/retryer.js","../node_modules/react-query/es/core/queryObserver.js","../node_modules/react-query/es/react/QueryErrorResetBoundary.js","../node_modules/react-query/es/react/useBaseQuery.js","../node_modules/react-query/es/react/useQuery.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n// TYPES\n// UTILS\nexport var isServer = typeof window === 'undefined';\nexport function noop() {\n  return undefined;\n}\nexport function functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nexport function isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nexport function ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nexport function difference(array1, array2) {\n  return array1.filter(function (x) {\n    return array2.indexOf(x) === -1;\n  });\n}\nexport function replaceAt(array, index, value) {\n  var copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nexport function timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nexport function parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return _extends({}, arg3, {\n      queryKey: arg1,\n      queryFn: arg2\n    });\n  }\n\n  return _extends({}, arg2, {\n    queryKey: arg1\n  });\n}\nexport function parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return _extends({}, arg3, {\n        mutationKey: arg1,\n        mutationFn: arg2\n      });\n    }\n\n    return _extends({}, arg2, {\n      mutationKey: arg1\n    });\n  }\n\n  if (typeof arg1 === 'function') {\n    return _extends({}, arg2, {\n      mutationFn: arg1\n    });\n  }\n\n  return _extends({}, arg1);\n}\nexport function parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [_extends({}, arg2, {\n    queryKey: arg1\n  }), arg3] : [arg1 || {}, arg2];\n}\nexport function parseMutationFilterArgs(arg1, arg2) {\n  return isQueryKey(arg1) ? _extends({}, arg2, {\n    mutationKey: arg1\n  }) : arg1;\n}\nexport function mapQueryStatusFilter(active, inactive) {\n  if (active === true && inactive === true || active == null && inactive == null) {\n    return 'all';\n  } else if (active === false && inactive === false) {\n    return 'none';\n  } else {\n    // At this point, active|inactive can only be true|false or false|true\n    // so, when only one value is provided, the missing one has to be the negated value\n    var isActive = active != null ? active : !inactive;\n    return isActive ? 'active' : 'inactive';\n  }\n}\nexport function matchQuery(filters, query) {\n  var active = filters.active,\n      exact = filters.exact,\n      fetching = filters.fetching,\n      inactive = filters.inactive,\n      predicate = filters.predicate,\n      queryKey = filters.queryKey,\n      stale = filters.stale;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  var queryStatusFilter = mapQueryStatusFilter(active, inactive);\n\n  if (queryStatusFilter === 'none') {\n    return false;\n  } else if (queryStatusFilter !== 'all') {\n    var isActive = query.isActive();\n\n    if (queryStatusFilter === 'active' && !isActive) {\n      return false;\n    }\n\n    if (queryStatusFilter === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nexport function matchMutation(filters, mutation) {\n  var exact = filters.exact,\n      fetching = filters.fetching,\n      predicate = filters.predicate,\n      mutationKey = filters.mutationKey;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nexport function hashQueryKeyByOptions(queryKey, options) {\n  var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n */\n\nexport function hashQueryKey(queryKey) {\n  var asArray = ensureQueryKeyArray(queryKey);\n  return stableValueHash(asArray);\n}\n/**\n * Hashes the value into a stable hash.\n */\n\nexport function stableValueHash(value) {\n  return JSON.stringify(value, function (_, val) {\n    return isPlainObject(val) ? Object.keys(val).sort().reduce(function (result, key) {\n      result[key] = val[key];\n      return result;\n    }, {}) : val;\n  });\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nexport function partialMatchKey(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nexport function partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !partialDeepEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nexport function replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  var array = Array.isArray(a) && Array.isArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    var aSize = array ? a.length : Object.keys(a).length;\n    var bItems = array ? b : Object.keys(b);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nexport function shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (var key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nexport function isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isQueryKey(value) {\n  return typeof value === 'string' || Array.isArray(value);\n}\nexport function isError(value) {\n  return value instanceof Error;\n}\nexport function sleep(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nexport function scheduleMicrotask(callback) {\n  Promise.resolve().then(callback).catch(function (error) {\n    return setTimeout(function () {\n      throw error;\n    });\n  });\n}\nexport function getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}","import { scheduleMicrotask } from './utils'; // TYPES\n\n// CLASS\nexport var NotifyManager = /*#__PURE__*/function () {\n  function NotifyManager() {\n    this.queue = [];\n    this.transactions = 0;\n\n    this.notifyFn = function (callback) {\n      callback();\n    };\n\n    this.batchNotifyFn = function (callback) {\n      callback();\n    };\n  }\n\n  var _proto = NotifyManager.prototype;\n\n  _proto.batch = function batch(callback) {\n    var result;\n    this.transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      this.transactions--;\n\n      if (!this.transactions) {\n        this.flush();\n      }\n    }\n\n    return result;\n  };\n\n  _proto.schedule = function schedule(callback) {\n    var _this = this;\n\n    if (this.transactions) {\n      this.queue.push(callback);\n    } else {\n      scheduleMicrotask(function () {\n        _this.notifyFn(callback);\n      });\n    }\n  }\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  ;\n\n  _proto.batchCalls = function batchCalls(callback) {\n    var _this2 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this2.schedule(function () {\n        callback.apply(void 0, args);\n      });\n    };\n  };\n\n  _proto.flush = function flush() {\n    var _this3 = this;\n\n    var queue = this.queue;\n    this.queue = [];\n\n    if (queue.length) {\n      scheduleMicrotask(function () {\n        _this3.batchNotifyFn(function () {\n          queue.forEach(function (callback) {\n            _this3.notifyFn(callback);\n          });\n        });\n      });\n    }\n  }\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  ;\n\n  _proto.setNotifyFunction = function setNotifyFunction(fn) {\n    this.notifyFn = fn;\n  }\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  ;\n\n  _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {\n    this.batchNotifyFn = fn;\n  };\n\n  return NotifyManager;\n}(); // SINGLETON\n\nexport var notifyManager = new NotifyManager();","import ReactDOM from 'react-dom';\nexport var unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates;","import { notifyManager } from '../core';\nimport { unstable_batchedUpdates } from './reactBatchedUpdates';\nnotifyManager.setBatchNotifyFunction(unstable_batchedUpdates);","// TYPES\n// FUNCTIONS\nvar logger = console;\nexport function getLogger() {\n  return logger;\n}\nexport function setLogger(newLogger) {\n  logger = newLogger;\n}","export var logger = console;","import { setLogger } from '../core';\nimport { logger } from './logger';\nsetLogger(logger);","import React from 'react';\nvar defaultContext = /*#__PURE__*/React.createContext(undefined);\nvar QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(contextSharing) {\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nexport var useQueryClient = function useQueryClient() {\n  var queryClient = React.useContext(getQueryClientContext(React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nexport var QueryClientProvider = function QueryClientProvider(_ref) {\n  var client = _ref.client,\n      _ref$contextSharing = _ref.contextSharing,\n      contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing,\n      children = _ref.children;\n  React.useEffect(function () {\n    client.mount();\n    return function () {\n      client.unmount();\n    };\n  }, [client]);\n  var Context = getQueryClientContext(contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};","export var Subscribable = /*#__PURE__*/function () {\n  function Subscribable() {\n    this.listeners = [];\n  }\n\n  var _proto = Subscribable.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this = this;\n\n    var callback = listener || function () {\n      return undefined;\n    };\n\n    this.listeners.push(callback);\n    this.onSubscribe();\n    return function () {\n      _this.listeners = _this.listeners.filter(function (x) {\n        return x !== callback;\n      });\n\n      _this.onUnsubscribe();\n    };\n  };\n\n  _proto.hasListeners = function hasListeners() {\n    return this.listeners.length > 0;\n  };\n\n  _proto.onSubscribe = function onSubscribe() {// Do nothing\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {// Do nothing\n  };\n\n  return Subscribable;\n}();","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { getDefaultState } from './mutation';\nimport { notifyManager } from './notifyManager';\nimport { Subscribable } from './subscribable';\n// CLASS\nexport var MutationObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(MutationObserver, _Subscribable);\n\n  function MutationObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n\n    _this.setOptions(options);\n\n    _this.bindMethods();\n\n    _this.updateResult();\n\n    return _this;\n  }\n\n  var _proto = MutationObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  };\n\n  _proto.setOptions = function setOptions(options) {\n    this.options = this.client.defaultMutationOptions(options);\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  };\n\n  _proto.onMutationUpdate = function onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    var notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.reset = function reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  };\n\n  _proto.mutate = function mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, _extends({}, this.options, {\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    }));\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  };\n\n  _proto.updateResult = function updateResult() {\n    var state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n\n    var result = _extends({}, state, {\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    });\n\n    this.currentResult = result;\n  };\n\n  _proto.notify = function notify(options) {\n    var _this2 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the mutate callbacks\n      if (_this2.mutateOptions) {\n        if (options.onSuccess) {\n          _this2.mutateOptions.onSuccess == null ? void 0 : _this2.mutateOptions.onSuccess(_this2.currentResult.data, _this2.currentResult.variables, _this2.currentResult.context);\n          _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(_this2.currentResult.data, null, _this2.currentResult.variables, _this2.currentResult.context);\n        } else if (options.onError) {\n          _this2.mutateOptions.onError == null ? void 0 : _this2.mutateOptions.onError(_this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);\n          _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(undefined, _this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        _this2.listeners.forEach(function (listener) {\n          listener(_this2.currentResult);\n        });\n      }\n    });\n  };\n\n  return MutationObserver;\n}(Subscribable);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getLogger } from './logger';\nimport { notifyManager } from './notifyManager';\nimport { Retryer } from './retryer';\nimport { noop } from './utils'; // TYPES\n\n// CLASS\nexport var Mutation = /*#__PURE__*/function () {\n  function Mutation(config) {\n    this.options = _extends({}, config.defaultOptions, config.options);\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n  }\n\n  var _proto = Mutation.prototype;\n\n  _proto.setState = function setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state: state\n    });\n  };\n\n  _proto.addObserver = function addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer);\n    }\n  };\n\n  _proto.removeObserver = function removeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n  };\n\n  _proto.cancel = function cancel() {\n    if (this.retryer) {\n      this.retryer.cancel();\n      return this.retryer.promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve();\n  };\n\n  _proto.continue = function _continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  };\n\n  _proto.execute = function execute() {\n    var _this = this;\n\n    var data;\n    var restored = this.state.status === 'loading';\n    var promise = Promise.resolve();\n\n    if (!restored) {\n      this.dispatch({\n        type: 'loading',\n        variables: this.options.variables\n      });\n      promise = promise.then(function () {\n        // Notify cache callback\n        _this.mutationCache.config.onMutate == null ? void 0 : _this.mutationCache.config.onMutate(_this.state.variables, _this);\n      }).then(function () {\n        return _this.options.onMutate == null ? void 0 : _this.options.onMutate(_this.state.variables);\n      }).then(function (context) {\n        if (context !== _this.state.context) {\n          _this.dispatch({\n            type: 'loading',\n            context: context,\n            variables: _this.state.variables\n          });\n        }\n      });\n    }\n\n    return promise.then(function () {\n      return _this.executeMutation();\n    }).then(function (result) {\n      data = result; // Notify cache callback\n\n      _this.mutationCache.config.onSuccess == null ? void 0 : _this.mutationCache.config.onSuccess(data, _this.state.variables, _this.state.context, _this);\n    }).then(function () {\n      return _this.options.onSuccess == null ? void 0 : _this.options.onSuccess(data, _this.state.variables, _this.state.context);\n    }).then(function () {\n      return _this.options.onSettled == null ? void 0 : _this.options.onSettled(data, null, _this.state.variables, _this.state.context);\n    }).then(function () {\n      _this.dispatch({\n        type: 'success',\n        data: data\n      });\n\n      return data;\n    }).catch(function (error) {\n      // Notify cache callback\n      _this.mutationCache.config.onError == null ? void 0 : _this.mutationCache.config.onError(error, _this.state.variables, _this.state.context, _this); // Log error\n\n      getLogger().error(error);\n      return Promise.resolve().then(function () {\n        return _this.options.onError == null ? void 0 : _this.options.onError(error, _this.state.variables, _this.state.context);\n      }).then(function () {\n        return _this.options.onSettled == null ? void 0 : _this.options.onSettled(undefined, error, _this.state.variables, _this.state.context);\n      }).then(function () {\n        _this.dispatch({\n          type: 'error',\n          error: error\n        });\n\n        throw error;\n      });\n    });\n  };\n\n  _proto.executeMutation = function executeMutation() {\n    var _this2 = this,\n        _this$options$retry;\n\n    this.retryer = new Retryer({\n      fn: function fn() {\n        if (!_this2.options.mutationFn) {\n          return Promise.reject('No mutationFn found');\n        }\n\n        return _this2.options.mutationFn(_this2.state.variables);\n      },\n      onFail: function onFail() {\n        _this2.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: function onPause() {\n        _this2.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: function onContinue() {\n        _this2.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n      retryDelay: this.options.retryDelay\n    });\n    return this.retryer.promise;\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this3 = this;\n\n    this.state = reducer(this.state, action);\n    notifyManager.batch(function () {\n      _this3.observers.forEach(function (observer) {\n        observer.onMutationUpdate(action);\n      });\n\n      _this3.mutationCache.notify(_this3);\n    });\n  };\n\n  return Mutation;\n}();\nexport function getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'failed':\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case 'pause':\n      return _extends({}, state, {\n        isPaused: true\n      });\n\n    case 'continue':\n      return _extends({}, state, {\n        isPaused: false\n      });\n\n    case 'loading':\n      return _extends({}, state, {\n        context: action.context,\n        data: undefined,\n        error: null,\n        isPaused: false,\n        status: 'loading',\n        variables: action.variables\n      });\n\n    case 'success':\n      return _extends({}, state, {\n        data: action.data,\n        error: null,\n        status: 'success',\n        isPaused: false\n      });\n\n    case 'error':\n      return _extends({}, state, {\n        data: undefined,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isPaused: false,\n        status: 'error'\n      });\n\n    case 'setState':\n      return _extends({}, state, action.state);\n\n    default:\n      return state;\n  }\n}","export function shouldThrowError(suspense, _useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary.apply(void 0, params);\n  } // Allow useErrorBoundary to override suspense's throwing behavior\n\n\n  if (typeof _useErrorBoundary === 'boolean') return _useErrorBoundary; // If suspense is enabled default to throwing errors\n\n  return !!suspense;\n}","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { noop, parseMutationArgs } from '../core/utils';\nimport { MutationObserver } from '../core/mutationObserver';\nimport { useQueryClient } from './QueryClientProvider';\nimport { shouldThrowError } from './utils'; // HOOK\n\nexport function useMutation(arg1, arg2, arg3) {\n  var mountedRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      forceUpdate = _React$useState[1];\n\n  var options = parseMutationArgs(arg1, arg2, arg3);\n  var queryClient = useQueryClient();\n  var obsRef = React.useRef();\n\n  if (!obsRef.current) {\n    obsRef.current = new MutationObserver(queryClient, options);\n  } else {\n    obsRef.current.setOptions(options);\n  }\n\n  var currentResult = obsRef.current.getCurrentResult();\n  React.useEffect(function () {\n    mountedRef.current = true;\n    var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function () {\n      if (mountedRef.current) {\n        forceUpdate(function (x) {\n          return x + 1;\n        });\n      }\n    }));\n    return function () {\n      mountedRef.current = false;\n      unsubscribe();\n    };\n  }, []);\n  var mutate = React.useCallback(function (variables, mutateOptions) {\n    obsRef.current.mutate(variables, mutateOptions).catch(noop);\n  }, []);\n\n  if (currentResult.error && shouldThrowError(undefined, obsRef.current.options.useErrorBoundary, [currentResult.error])) {\n    throw currentResult.error;\n  }\n\n  return _extends({}, currentResult, {\n    mutate: mutate,\n    mutateAsync: currentResult.mutate\n  });\n}","import _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { Subscribable } from './subscribable';\nimport { isServer } from './utils';\nexport var FocusManager = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(FocusManager, _Subscribable);\n\n  function FocusManager() {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n\n    _this.setup = function (onFocus) {\n      var _window;\n\n      if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n        var listener = function listener() {\n          return onFocus();\n        }; // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return function () {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = FocusManager.prototype;\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  };\n\n  _proto.setEventListener = function setEventListener(setup) {\n    var _this$cleanup2,\n        _this2 = this;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(function (focused) {\n      if (typeof focused === 'boolean') {\n        _this2.setFocused(focused);\n      } else {\n        _this2.onFocus();\n      }\n    });\n  };\n\n  _proto.setFocused = function setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  };\n\n  _proto.onFocus = function onFocus() {\n    this.listeners.forEach(function (listener) {\n      listener();\n    });\n  };\n\n  _proto.isFocused = function isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  };\n\n  return FocusManager;\n}(Subscribable);\nexport var focusManager = new FocusManager();","import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  this.abort = config.abort;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continueRetry = function () {\n    cancelRetry = false;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions));\n        _this.abort == null ? void 0 : _this.abort(); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nimport { getLogger } from './logger';\nimport { isCancelledError } from './retryer';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.trackedProps = [];\n    _this.previousSelectError = null;\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  };\n\n  _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options, notifyOptions) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    var mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    var nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  };\n\n  _proto.getOptimisticResult = function getOptimisticResult(options) {\n    var defaultedOptions = this.client.defaultQueryObserverOptions(options);\n    var query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    return this.createResult(query, defaultedOptions);\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.trackResult = function trackResult(result, defaultedOptions) {\n    var _this2 = this;\n\n    var trackedResult = {};\n\n    var trackProp = function trackProp(key) {\n      if (!_this2.trackedProps.includes(key)) {\n        _this2.trackedProps.push(key);\n      }\n    };\n\n    Object.keys(result).forEach(function (key) {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: function get() {\n          trackProp(key);\n          return result[key];\n        }\n      });\n    });\n\n    if (defaultedOptions.useErrorBoundary || defaultedOptions.suspense) {\n      trackProp('error');\n    }\n\n    return trackedResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this3 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this3.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(_extends({}, options, {\n      meta: {\n        refetchPage: options == null ? void 0 : options.refetchPage\n      }\n    }));\n  };\n\n  _proto.fetchOptimistic = function fetchOptimistic(options) {\n    var _this4 = this;\n\n    var defaultedOptions = this.client.defaultQueryObserverOptions(options);\n    var query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    return query.fetch().then(function () {\n      return _this4.createResult(query, defaultedOptions);\n    });\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this5 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this5.updateResult();\n\n      return _this5.currentResult;\n    });\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this6 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this6.currentResult.isStale) {\n        _this6.updateResult();\n      }\n    }, timeout);\n  };\n\n  _proto.computeRefetchInterval = function computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {\n    var _this7 = this;\n\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this7.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  };\n\n  _proto.createResult = function createResult(query, options) {\n    var prevQuery = this.currentQuery;\n    var prevOptions = this.options;\n    var prevResult = this.currentResult;\n    var prevResultState = this.currentResultState;\n    var prevResultOptions = this.currentResultOptions;\n    var queryChange = query !== prevQuery;\n    var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    var state = query.state;\n    var dataUpdatedAt = state.dataUpdatedAt,\n        error = state.error,\n        errorUpdatedAt = state.errorUpdatedAt,\n        isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data; // Optimistically set result in fetching state if needed\n\n    if (options.optimisticResults) {\n      var mounted = this.hasListeners();\n      var fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        isFetching = true;\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n        var _this$previousSelect;\n\n        // Memoize select result\n        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === ((_this$previousSelect = this.previousSelect) == null ? void 0 : _this$previousSelect.fn) && !this.previousSelectError) {\n          data = this.previousSelect.result;\n        } else {\n          try {\n            data = options.select(state.data);\n\n            if (options.structuralSharing !== false) {\n              data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);\n            }\n\n            this.previousSelect = {\n              fn: options.select,\n              result: data\n            };\n            this.previousSelectError = null;\n          } catch (selectError) {\n            getLogger().error(selectError);\n            error = selectError;\n            this.previousSelectError = selectError;\n            errorUpdatedAt = Date.now();\n            status = 'error';\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && (status === 'loading' || status === 'idle')) {\n      var placeholderData; // Memoize placeholder data\n\n      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n\n            if (options.structuralSharing !== false) {\n              placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);\n            }\n\n            this.previousSelectError = null;\n          } catch (selectError) {\n            getLogger().error(selectError);\n            error = selectError;\n            this.previousSelectError = selectError;\n            errorUpdatedAt = Date.now();\n            status = 'error';\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    var result = {\n      status: status,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      isIdle: status === 'idle',\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: error,\n      errorUpdatedAt: errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {\n    if (!prevResult) {\n      return true;\n    }\n\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    if (notifyOnChangeProps === 'tracked' && !this.trackedProps.length) {\n      return true;\n    }\n\n    var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;\n    return Object.keys(result).some(function (key) {\n      var typedKey = key;\n      var changed = result[typedKey] !== prevResult[typedKey];\n      var isIncluded = includedProps == null ? void 0 : includedProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n      return changed && !isExcluded && (!includedProps || isIncluded);\n    });\n  };\n\n  _proto.updateResult = function updateResult(notifyOptions) {\n    var prevResult = this.currentResult;\n    this.currentResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify if something has changed\n\n    if (shallowEqualObjects(this.currentResult, prevResult)) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var defaultNotifyOptions = {\n      cache: true\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify(_extends({}, defaultNotifyOptions, notifyOptions));\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    var prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this8 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this8.listeners.forEach(function (listener) {\n          listener(_this8.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this8.client.getQueryCache().notify({\n          query: _this8.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    var value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}","import React from 'react'; // CONTEXT\n\nfunction createValue() {\n  var _isReset = false;\n  return {\n    clearReset: function clearReset() {\n      _isReset = false;\n    },\n    reset: function reset() {\n      _isReset = true;\n    },\n    isReset: function isReset() {\n      return _isReset;\n    }\n  };\n}\n\nvar QueryErrorResetBoundaryContext = /*#__PURE__*/React.createContext(createValue()); // HOOK\n\nexport var useQueryErrorResetBoundary = function useQueryErrorResetBoundary() {\n  return React.useContext(QueryErrorResetBoundaryContext);\n}; // COMPONENT\n\nexport var QueryErrorResetBoundary = function QueryErrorResetBoundary(_ref) {\n  var children = _ref.children;\n  var value = React.useMemo(function () {\n    return createValue();\n  }, []);\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};","import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nimport { shouldThrowError } from './utils';\nexport function useBaseQuery(options, Observer) {\n  var mountedRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      forceUpdate = _React$useState[1];\n\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions.optimisticResults = true; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    } // Set cache time to 1 if the option has been set to 0\n    // when using suspense to prevent infinite loop of fetches\n\n\n    if (defaultedOptions.cacheTime === 0) {\n      defaultedOptions.cacheTime = 1;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  var _React$useState2 = React.useState(function () {\n    return new Observer(queryClient, defaultedOptions);\n  }),\n      observer = _React$useState2[0];\n\n  var result = observer.getOptimisticResult(defaultedOptions);\n  React.useEffect(function () {\n    mountedRef.current = true;\n    errorResetBoundary.clearReset();\n    var unsubscribe = observer.subscribe(notifyManager.batchCalls(function () {\n      if (mountedRef.current) {\n        forceUpdate(function (x) {\n          return x + 1;\n        });\n      }\n    })); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    observer.updateResult();\n    return function () {\n      mountedRef.current = false;\n      unsubscribe();\n    };\n  }, [errorResetBoundary, observer]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading) {\n    throw observer.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var data = _ref.data;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(function (error) {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  if (defaultedOptions.notifyOnChangeProps === 'tracked') {\n    result = observer.trackResult(result, defaultedOptions);\n  }\n\n  return result;\n}","import { QueryObserver } from '../core';\nimport { parseQueryArgs } from '../core/utils';\nimport { useBaseQuery } from './useBaseQuery'; // HOOK\n\nexport function useQuery(arg1, arg2, arg3) {\n  var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}"],"names":["isServer","window","noop","isValidTimeout","value","Infinity","replaceEqualDeep","a","b","array","Array","isArray","isPlainObject","aSize","length","Object","keys","bItems","bSize","copy","equalItems","i","key","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isQueryKey","scheduleMicrotask","callback","Promise","resolve","then","catch","error","setTimeout","NotifyManager","this","queue","transactions","notifyFn","batchNotifyFn","_proto","batch","result","flush","schedule","_this","push","batchCalls","_this2","_len","arguments","args","_key","apply","_this3","forEach","setNotifyFunction","fn","setBatchNotifyFunction","notifyManager","unstable_batchedUpdates","ReactDOM","logger","console","getLogger","defaultContext","React","undefined","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","Error","Subscribable","listeners","subscribe","listener","onSubscribe","filter","x","onUnsubscribe","hasListeners","MutationObserver","_Subscribable","client","options","setOptions","bindMethods","updateResult","_inheritsLoose","mutate","bind","reset","defaultMutationOptions","_this$currentMutation","currentMutation","removeObserver","onMutationUpdate","action","notifyOptions","type","onSuccess","onError","notify","getCurrentResult","currentResult","variables","mutateOptions","getMutationCache","build","_extends","addObserver","execute","state","context","data","failureCount","isPaused","status","isLoading","isSuccess","isError","isIdle","onSettled","shouldThrowError","suspense","_useErrorBoundary","params","useMutation","arg1","arg2","arg3","mountedRef","forceUpdate","mutationKey","mutationFn","parseMutationArgs","obsRef","current","unsubscribe","useErrorBoundary","mutateAsync","focusManager","FocusManager","setup","onFocus","_window","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","_this$cleanup2","focused","setFocused","isFocused","document","includes","visibilityState","CancelledError","revert","silent","QueryObserver","trackedProps","previousSelectError","remove","refetch","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearTimers","prevOptions","prevQuery","defaultQueryObserverOptions","enabled","queryKey","updateQuery","mounted","shouldFetchOptionally","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","defaultedOptions","query","getQueryCache","createResult","trackResult","trackedResult","trackProp","defineProperty","configurable","enumerable","get","getNextResult","reject","isFetching","throwOnError","getCurrentQuery","fetch","meta","refetchPage","fetchOptimistic","_this4","fetchOptions","_this5","promise","_this6","clearStaleTimeout","isStale","updatedAt","timeout","dataUpdatedAt","Math","max","Date","now","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","_this7","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","isPreviousData","isPlaceholderData","optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","dataUpdateCount","select","_this$previousSelect","previousSelect","structuralSharing","selectError","placeholderData","fetchFailureCount","errorUpdateCount","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","shouldNotifyListeners","_this$options","notifyOnChangeProps","notifyOnChangePropsExclusions","includedProps","some","typedKey","changed","isIncluded","isExcluded","shallowEqualObjects","defaultNotifyOptions","cache","onQueryUpdate","_this8","retryOnMount","shouldLoadOnMount","refetchOnMount","field","isStaleByTime","createValue","_isReset","clearReset","isReset","QueryErrorResetBoundaryContext","useBaseQuery","Observer","errorResetBoundary","cacheTime","observer","_ref","useQuery","parsedOptions","queryFn","parseQueryArgs"],"sourceRoot":""}